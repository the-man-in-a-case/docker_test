apiVersion: v1
kind: ConfigMap
metadata:
  name: manager-script
  namespace: default
data:
  manager.py: |
    """
    manager.py
    
    - 运行时在 Pod 内，使用 in-cluster kubeconfig 修改自身所在的 Deployment，替换 podTemplate 为多容器模板。
    - 修改 deployment 时会在 annotation 上加上时间戳以触发滚动更新。
    - 包含错误处理和重试机制，确保配置更新成功。
    """
    import os
    import time
    import logging
    import json
    from kubernetes import client, config
    from kubernetes.client.rest import ApiException
    from typing import Dict, Any
    
    # 配置日志
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger('pod-configurator')
    
    # 环境变量
    NAMESPACE = os.environ.get('POD_NAMESPACE', 'default')
    DEPLOYMENT_NAME = os.environ.get('DEPLOYMENT_NAME', 'manager-deployment')
    # 添加重试配置
    MAX_RETRIES = 3
    RETRY_DELAY = 5  # 秒
    
    # 多容器模板配置
    MULTI_CONTAINERS_TEMPLATE = {
        "spec": {
            "template": {
                "metadata": {
                    "annotations": {
                        "updated-by": "manager-script"
                    }
                },
                "spec": {
                    "containers": [
                        {
                            "name": "testserver",
                            "image": "nginx:alpine",
                            "ports": [{"containerPort": 80}],
                            "env": [{"name": "ROLE", "value": "server"}],
                            "resources": {
                                "requests": {
                                    "cpu": "10m",
                                    "memory": "32Mi"
                                },
                                "limits": {
                                    "cpu": "100m",
                                    "memory": "128Mi"
                                }
                            }
                        },
                        {
                            "name": "testclient",
                            "image": "busybox:latest",
                            "env": [{"name": "ROLE", "value": "client"}],
                            "command": ["/bin/sh", "-c", "sleep infinity"],
                            "resources": {
                                "requests": {
                                    "cpu": "10m",
                                    "memory": "32Mi"
                                },
                                "limits": {
                                    "cpu": "100m",
                                    "memory": "128Mi"
                                }
                            }
                        }
                    ],
                    "dnsPolicy": "ClusterFirst",
                    "restartPolicy": "Always"
                }
            }
        }
    }
    
    
    def setup_kubernetes_client() -> client.AppsV1Api:
        """设置Kubernetes客户端"""
        try:
            config.load_incluster_config()
            logger.info("成功加载in-cluster配置")
            return client.AppsV1Api()
        except Exception as e:
            logger.error(f"加载Kubernetes配置失败: {str(e)}")
            raise
    
    
    def get_current_deployment(apps_v1: client.AppsV1Api) -> Dict[str, Any]:
        """获取当前Deployment配置"""
        for attempt in range(MAX_RETRIES):
            try:
                deployment = apps_v1.read_namespaced_deployment(DEPLOYMENT_NAME, NAMESPACE)
                logger.info(f"成功读取Deployment {DEPLOYMENT_NAME}，当前副本数: {deployment.spec.replicas}")
                return deployment
            except ApiException as e:
                logger.error(f"读取Deployment失败 (尝试 {attempt+1}/{MAX_RETRIES}): {str(e)}")
                if attempt < MAX_RETRIES - 1:
                    time.sleep(RETRY_DELAY)
                else:
                    raise
    
    
    def create_patch() -> Dict[str, Any]:
        """创建Deployment补丁以更新为多容器配置"""
        patch = {
            "spec": {
                "template": MULTI_CONTAINERS_TEMPLATE['spec']['template']
            }
        }
        
        # 添加时间戳确保滚动更新被触发
        ts = str(int(time.time()))
        patch['spec']['template']['metadata'].setdefault('annotations', {})
        patch['spec']['template']['metadata']['annotations']['updated-at'] = ts
        patch['spec']['template']['metadata']['annotations']['original-containers'] = 'single'
        
        logger.info(f"创建补丁配置，时间戳: {ts}")
        return patch
    
    
    def apply_deployment_patch(apps_v1: client.AppsV1Api, patch: Dict[str, Any]) -> None:
        """应用Deployment补丁"""
        for attempt in range(MAX_RETRIES):
            try:
                apps_v1.patch_namespaced_deployment(name=DEPLOYMENT_NAME, namespace=NAMESPACE, body=patch)
                logger.info(f"成功应用Deployment补丁")
                return
            except ApiException as e:
                logger.error(f"应用Deployment补丁失败 (尝试 {attempt+1}/{MAX_RETRIES}): {str(e)}")
                if attempt < MAX_RETRIES - 1:
                    time.sleep(RETRY_DELAY)
                else:
                    raise
    
    
    def verify_patch_application(apps_v1: client.AppsV1Api) -> bool:
        """验证补丁是否成功应用"""
        try:
            deployment = apps_v1.read_namespaced_deployment(DEPLOYMENT_NAME, NAMESPACE)
            annotations = deployment.spec.template.metadata.annotations or {}
            if 'updated-at' in annotations and annotations.get('original-containers') == 'single':
                logger.info("补丁应用验证成功")
                return True
            else:
                logger.warning("补丁应用验证失败，注解不匹配")
                return False
        except Exception as e:
            logger.error(f"验证补丁应用失败: {str(e)}")
            return False
    
    
    def main():
        """主函数"""
        logger.info(f"Pod配置管理器启动，目标Deployment: {DEPLOYMENT_NAME}，命名空间: {NAMESPACE}")
        
        try:
            # 等待集群稳定
            logger.info("等待集群稳定...")
            time.sleep(5)
            
            # 初始化Kubernetes客户端
            apps_v1 = setup_kubernetes_client()
            
            # 读取当前Deployment
            get_current_deployment(apps_v1)
            
            # 创建多容器配置补丁
            patch = create_patch()
            
            # 应用补丁
            apply_deployment_patch(apps_v1, patch)
            
            # 验证补丁应用
            verify_patch_application(apps_v1)
            
            logger.info("Pod配置更新完成。退出管理器以允许新的Pod滚动更新。")
            
        except Exception as e:
            logger.error(f"执行过程中发生错误: {str(e)}")
            # 以非零状态码退出，表明执行失败
            os._exit(1)
    
    
    if __name__ == '__main__':
        main()