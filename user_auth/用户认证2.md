下面给你一套“能跑起来”的最小可行方案（MVP），把需求拆成两部分实现：

1. **Django 用户管理 & 认证微服务**

* 在新增/删除用户时，同步在 K8s 中创建/删除该用户的“专属 Nginx Pod + Service”。
* 提供 `POST /auth/validate` 接口：从 Cookie/Token 校验用户，成功后返回 `200` 并在响应头里注入 `X-User-ID`（供下游路由用）。

2. **Kubernetes 入口与路由**

* 用 NGINX Ingress Controller 做入口，并使用 `auth-url` 调用上面的 Django 认证接口。
* Ingress 把请求转发给一个“**Dispatcher**（调度反向代理）”服务。Dispatcher 根据认证返回头 `X-User-ID`，**按用户动态转发**到 `user-<id>-svc`（就是 Django 为每个用户创建的 Service，后端对接该用户唯一的 Nginx Pod）。

> 说明：直接让 **Ingress** 自身按 Cookie/Token 动态路由到“任意 service 名称”的能力在开源版中不可行（它需要静态后端集），因此采用“**Ingress → Dispatcher（动态转发）→ 用户专属 Service**”的通用做法，仍满足你“按 Cookie/Token 查库 → 路由到专属 Pod”的目标。

---

# 1) Django 侧：用户模型、K8s 同步与认证接口

## 1.1 依赖

```bash
pip install django djangorestframework kubernetes python-decouple
```

## 1.2 settings（节选）

```python
# settings.py
INSTALLED_APPS = [
    # ...
    'rest_framework',
    'users',           # 你的用户应用
]

# 认证用的共享密钥（也可用 JWT）
from decouple import config
AUTH_SHARED_SECRET = config('AUTH_SHARED_SECRET', default='changeme')

# K8s 访问方式（in-cluster 或 kubeconfig）
K8S_IN_CLUSTER = config('K8S_IN_CLUSTER', cast=bool, default=True)
K8S_NAMESPACE  = config('K8S_NAMESPACE', default='default')
```

## 1.3 K8s 客户端辅助

```python
# users/k8s.py
from kubernetes import client, config
from django.conf import settings

def k8s():
    if settings.K8S_IN_CLUSTER:
        config.load_incluster_config()
    else:
        config.load_kube_config()
    return client.CoreV1Api()

def user_names(user_id: int):
    pod_name = f"user-{user_id}-nginx"
    svc_name = f"user-{user_id}-svc"
    return pod_name, svc_name

def ensure_user_pod_service(user_id: int):
    v1 = k8s()
    ns = settings.K8S_NAMESPACE
    pod_name, svc_name = user_names(user_id)

    # Pod（一个简单的 Nginx）
    pod = client.V1Pod(
        metadata=client.V1ObjectMeta(
            name=pod_name,
            labels={'app': 'user-nginx', 'user-id': str(user_id)}
        ),
        spec=client.V1PodSpec(
            containers=[client.V1Container(
                name="nginx",
                image="nginx:1.27-alpine",
                ports=[client.V1ContainerPort(container_port=80)],
                # 你可将用户静态资源或配置挂载进来
            )]
        )
    )

    # 创建或已存在忽略
    try:
        v1.create_namespaced_pod(namespace=ns, body=pod)
    except client.exceptions.ApiException as e:
        if e.status != 409:  # AlreadyExists
            raise

    # Service（ClusterIP，供 Dispatcher 访问）
    svc = client.V1Service(
        metadata=client.V1ObjectMeta(name=svc_name),
        spec=client.V1ServiceSpec(
            selector={'app': 'user-nginx', 'user-id': str(user_id)},
            ports=[client.V1ServicePort(port=80, target_port=80)]
        )
    )
    try:
        v1.create_namespaced_service(namespace=ns, body=svc)
    except client.exceptions.ApiException as e:
        if e.status != 409:
            raise

def delete_user_pod_service(user_id: int):
    v1 = k8s()
    ns = settings.K8S_NAMESPACE
    pod_name, svc_name = user_names(user_id)

    # 优雅删除
    body = client.V1DeleteOptions(grace_period_seconds=10)
    for kind, deleter in [('pod', v1.delete_namespaced_pod),
                          ('svc', v1.delete_namespaced_service)]:
        try:
            deleter(name=pod_name if kind=='pod' else svc_name, namespace=ns, body=body)
        except client.exceptions.ApiException as e:
            if e.status != 404:
                raise
```

## 1.4 用户模型 & 信号：创建/删除 K8s 资源

```python
# users/models.py
from django.db import models

class User(models.Model):
    username = models.CharField(max_length=64, unique=True)
    token = models.CharField(max_length=128, unique=True)  # 简化示例；实际请使用哈希或 JWT
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.username
```

```python
# users/signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from .models import User
from .k8s import ensure_user_pod_service, delete_user_pod_service

@receiver(post_save, sender=User)
def on_user_created(sender, instance, created, **kwargs):
    if created:
        ensure_user_pod_service(instance.id)

@receiver(post_delete, sender=User)
def on_user_deleted(sender, instance, **kwargs):
    delete_user_pod_service(instance.id)
```

```python
# users/apps.py
from django.apps import AppConfig
class UsersConfig(AppConfig):
    name = 'users'
    def ready(self):
        from . import signals  # noqa
```

## 1.5 认证接口（AuthN 微服务）

* 从请求中读取 Cookie `session` 或 Header `Authorization: Bearer <token>`。
* 校验成功后返回 `200`，并设置 `X-User-ID` 供下游使用；失败返回 `401`。

```python
# users/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.conf import settings
from .models import User

def extract_token(request):
    # 1) Cookie 优先
    cookie = request.COOKIES.get('session')
    if cookie:
        return cookie
    # 2) Bearer Token
    auth = request.META.get('HTTP_AUTHORIZATION', '')
    if auth.lower().startswith('bearer '):
        return auth[7:].strip()
    return None

@api_view(['GET','POST'])
def auth_validate(request):
    token = extract_token(request)
    if not token:
        return Response(status=status.HTTP_401_UNAUTHORIZED)

    try:
        user = User.objects.get(token=token)
    except User.DoesNotExist:
        return Response(status=status.HTTP_401_UNAUTHORIZED)

    # 认证通过，在响应头里回传用户标识
    resp = Response(status=status.HTTP_200_OK)
    resp['X-User-ID'] = str(user.id)
    return resp
```

```python
# users/urls.py
from django.urls import path
from .views import auth_validate
urlpatterns = [
    path('auth/validate', auth_validate),
]
```

---

# 2) Kubernetes 清单：RBAC、Dispatcher、Ingress

## 2.1 给 Django 分配 RBAC（允许创建/删除 Pod & Service）

```yaml
# rbac-django.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: django-sa
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: django-user-pod-manager
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["pods","services"]
    verbs: ["get","list","watch","create","delete","patch","update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: django-user-pod-manager-binding
  namespace: default
subjects:
  - kind: ServiceAccount
    name: django-sa
roleRef:
  kind: Role
  name: django-user-pod-manager
  apiGroup: rbac.authorization.k8s.io
```

## 2.2 部署 Django（示例）

```yaml
# deploy-django.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: django
spec:
  replicas: 1
  selector:
    matchLabels: {app: django}
  template:
    metadata:
      labels: {app: django}
    spec:
      serviceAccountName: django-sa
      containers:
        - name: web
          image: yourrepo/django-users:latest
          env:
            - name: K8S_IN_CLUSTER
              value: "true"
            - name: K8S_NAMESPACE
              value: "default"
            - name: AUTH_SHARED_SECRET
              valueFrom:
                secretKeyRef:
                  name: django-auth-secret
                  key: secret
          ports:
            - containerPort: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: django
spec:
  selector: {app: django}
  ports:
    - port: 8000
      targetPort: 8000
```

## 2.3 Dispatcher（OpenResty/Nginx + Lua）

* 收到 Ingress 转发流量后，从请求头 `X-User-ID` 取用户 ID。
* 将其拼接为 `http://user-<id>-svc.default.svc.cluster.local` 并转发。
* 如未认证/未带头，返回 401 或 404。

```yaml
# cm-dispatcher.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: dispatcher-conf
data:
  nginx.conf: |
    worker_processes  auto;
    events { worker_connections  1024; }
    http {
      lua_shared_dict d 10m;
      resolver kube-dns.kube-system.svc.cluster.local valid=5s;  # 也可用 10.96.0.10 或 CLUSTER_DNS

      server {
        listen 8080;

        location / {
          set $userid "";
          if ($http_x_user_id != "") { set $userid $http_x_user_id; }

          access_by_lua_block {
            local uid = ngx.var.userid
            if not uid or uid == "" then
              return ngx.exit(401)
            end
            -- 构造上游（用户专属 Service 的 FQDN）
            ngx.var.target = string.format("http://user-%s-svc.default.svc.cluster.local", uid)
          }

          proxy_http_version 1.1;
          proxy_set_header Connection "";
          proxy_set_header Host $host;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

          proxy_pass $target;
        }
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dispatcher
spec:
  replicas: 2
  selector:
    matchLabels: {app: dispatcher}
  template:
    metadata:
      labels: {app: dispatcher}
    spec:
      containers:
        - name: openresty
          image: openresty/openresty:1.25.3.1-alpine
          ports:
            - containerPort: 8080
          volumeMounts:
            - name: conf
              mountPath: /usr/local/openresty/nginx/conf/nginx.conf
              subPath: nginx.conf
      volumes:
        - name: conf
          configMap:
            name: dispatcher-conf
---
apiVersion: v1
kind: Service
metadata:
  name: dispatcher
spec:
  selector: {app: dispatcher}
  ports:
    - port: 80
      targetPort: 8080
```

> 注意：`resolver` 需指向你集群的 DNS。常见为 `kube-dns.kube-system.svc.cluster.local`，或 CoreDNS `kube-dns`/`coredns` 的 ClusterIP。

## 2.4 Ingress（带外部认证）

* 使用 `nginx.ingress.kubernetes.io/auth-url` 调用 Django 认证接口。
* 把 `X-User-ID` 传递给后端（Dispatcher）。

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: user-router
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/auth-url: "http://django.default.svc.cluster.local:8000/auth/validate"
    nginx.ingress.kubernetes.io/auth-method: "POST"      # 或 GET；保持与后端一致
    nginx.ingress.kubernetes.io/auth-response-headers: "X-User-ID"
    nginx.ingress.kubernetes.io/proxy-buffering: "off"
spec:
  rules:
    - host: your.domain.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: dispatcher
                port:
                  number: 80
```

---

# 3) 端到端流程（关键点）

1. **创建用户**

   * 你在 Django 管理/接口里新增 `User(username, token=...)`。
   * `post_save` 信号触发，在 K8s 里创建：

     * Pod：`user-<id>-nginx`（Nginx）
     * Service：`user-<id>-svc`（指向该 Pod）

2. **请求进入**

   * 客户端带 `Cookie: session=<token>` 或 `Authorization: Bearer <token>` 请求 `https://your.domain.com/xxx`。
   * NGINX Ingress 先调用 `django/auth/validate`：校验成功 → 带回 `X-User-ID: <id>`。
   * Ingress 把原请求（携带此头）转发到 `dispatcher`。
   * Dispatcher 读取 `X-User-ID`，拼接 `http://user-<id>-svc.default.svc.cluster.local`，`proxy_pass` 到用户专属 Nginx。

3. **删除用户**

   * 删除 Django 用户 → `post_delete` 信号触发，删除该用户的 Pod 和 Service。若此时仍有请求，会在 Dispatcher 层得到 404（Service 不存在的 DNS 解析失败）或 502/504（Pod 不就绪），你可在 Lua 里增加“兜底页”。

---

# 4) 本地/联调测试

## 4.1 创建一个用户（伪造 token）

```python
from users.models import User
u = User.objects.create(username='alice', token='token-alice-123')
print(u.id)  # 记下 ID，例如 7
```

确认 K8s 中出现：

```bash
kubectl get pod,svc | grep user-7
```

## 4.2 curl 测试（Cookie）

```bash
curl -i -H "Host: your.domain.com" \
     --cookie "session=token-alice-123" \
     http://<INGRESS-EXTERNAL-IP>/
```

预期：返回 Nginx 默认页，`user-7-nginx` 提供（你可在其镜像里放置用户专属内容）。

## 4.3 curl 测试（Bearer）

```bash
curl -i -H "Host: your.domain.com" \
     -H "Authorization: Bearer token-alice-123" \
     http://<INGRESS-EXTERNAL-IP>/anything
```

---

# 5) 可扩展与加固建议

* **用户资源打包为 Deployment/StatefulSet**：当前用 Pod 演示最简单路径，生产建议用 Deployment（自动重建），并保持 Service 名称不变。
* **限流与熔断**：在 Dispatcher 中对上游失败加重试/熔断；Ingress 层可配 `limit-req`。
* **健康检查**：用户 Nginx Pod 配置就绪探针；Service/Deployment 配置 `readinessProbe`。
* **安全**：认证改用 JWT（Django 发、Ingress `auth-url` 验签 or 仍由 Django 验证），并对 `X-User-ID` 做签名或通过 mTLS 在 Ingress ↔ Dispatcher 间保障可信。
* **资源回收**：用户长时间不活跃可自动缩容/停用；需要时再拉起（在 Django 的信号或定时任务里控制）。
* **多命名空间**：按租户/项目划分 namespace，Dispatcher 里拼接 FQDN 时带不同 ns。
* **日志追踪**：把 `X-User-ID` 透传到后端，便于审计与计费。

---

如果你希望，我可以把上述清单与 Django 代码打包成一个可直接 `kubectl apply -f` 与 `docker-compose build/push` 的最小仓库结构（含 Makefile 与 helm/chart 版本），或者改造成“每用户 Deployment + ConfigMap（挂载个性化 Nginx 配置/静态内容）”。
