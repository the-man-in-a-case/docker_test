# ========== shared 文件夹整合 ==========

# ========== celery.py ==========
"""
import os
from celery import Celery

os.environ.setdefault("DJANGO_SETTINGS_MODULE", os.getenv("DJANGO_SETTINGS_MODULE", "managersvc.settings"))
app = Celery("managersvc")
app.conf.broker_url = os.getenv("CELERY_BROKER_URL", "redis://redis:6379/0")
app.conf.result_backend = os.getenv("CELERY_RESULT_BACKEND", "redis://redis:6379/1")
app.autodiscover_tasks()
"""

# ========== settings_base.py ==========
"""
import os
from decouple import config
from datetime import timedelta

SECRET_KEY = config('DJANGO_SECRET', default='e1%whp(q2u#bu8scs$jf4cobp*s25o81fg_02d%w9vxbt-^g5_')
DEBUG = config('DJANGO_DEBUG', cast=bool, default=False)
ALLOWED_HOSTS = ['*']

AUTH_USER_MODEL = 'shared.User'

INSTALLED_APPS = [
    'django.contrib.contenttypes',
    'django.contrib.auth',
    'django.contrib.admin',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'shared',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'shared.middleware.UpdateLastAccessMiddleware',
]


DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': config('MYSQL_DB', default='tenants'),
        'USER': config('MYSQL_USER', default='tenants'),
        'PASSWORD': config('MYSQL_PASSWORD', default='tenants_pass'),
        'HOST': config('MYSQL_HOST', default='mysql'),
        'PORT': config('MYSQL_PORT', default='3306'),
        'CONN_MAX_AGE': 60,
    }
}

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": (
        "rest_framework.permissions.IsAuthenticated",
    ),
}


SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
    "ROTATE_REFRESH_TOKENS": True,
    "BLACKLIST_AFTER_ROTATION": True,
    "SIGNING_KEY": config('JWT_SECRET', default='jwt-secret'),
    "ALGORITHM": "HS256",
    "AUTH_HEADER_TYPES": ("Bearer",),
    "AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
}


JWT_SECRET = config('JWT_SECRET', default='jwt-secret')
ROUTE_SIGNING_SECRET = config('ROUTE_SIGNING_SECRET', default='route-sign')
TIME_ZONE = 'Asia/Taipei'
USE_TZ = True

# K8s
K8S_IN_CLUSTER = config('K8S_IN_CLUSTER', cast=bool, default=True)
DEFAULT_USER_NS = config('DEFAULT_USER_NS', default='tenant-a')  # 可与多命名空间匹配
K8S_DOMAIN_SUFFIX = config('K8S_DOMAIN_SUFFIX', default='svc.cluster.local')

# Celery（若在 Manager 使用）
CELERY_BROKER_URL = config('CELERY_BROKER_URL', default='redis://redis:6379/0')
CELERY_RESULT_BACKEND = config('CELERY_RESULT_BACKEND', default='redis://redis:6379/1')
"""

# ========== utils.py ==========
"""
import hmac, time, hashlib, jwt
from django.conf import settings

def jwt_encode(payload: dict, ttl_sec: int = 3600):
    return jwt.encode(
        {**payload, "exp": int(time.time()) + ttl_sec},
        settings.JWT_SECRET, algorithm="HS256"
    )

def jwt_decode(token: str):
    return jwt.decode(token, settings.JWT_SECRET, algorithms=["HS256"])

def sign_headers(user_id: int, namespace: str, ts: int | None = None):
    """生成 HMAC-SHA256 签名，供 Ingress→Dispatcher→后端校验防伪造"""
    ts = ts or int(time.time())
    msg = f"{user_id}:{namespace}:{ts}".encode()
    sig = hmac.new(settings.ROUTE_SIGNING_SECRET.encode(), msg, hashlib.sha256).hexdigest()
    return ts, sig
"""

# ========== middleware.py ==========
"""
from django.utils import timezone
from django.utils.deprecation import MiddlewareMixin

class UpdateLastAccessMiddleware(MiddlewareMixin):
    def process_request(self, request):
        user = getattr(request, "user", None)
        if user and user.is_authenticated:
            # 轻量更新（避免每次写库的开销，可以加节流，例如每 60s 才写）
            user.last_access_at = timezone.now()
            user.save(update_fields=["last_access_at"])
"""

# ========== models.py ==========
"""
# from django.db import models

# class TenantUser(models.Model):
#     username = models.CharField(max_length=64, unique=True)
#     # 简化起见，仍保留 token 字段；生产用 JWT（此字段可作为旧 token 或互操作用途）
#     # token = models.CharField(max_length=256, unique=True)
#     token = models.CharField(
#         max_length=255,  # 改为 255 或更小
#         unique=True,
#         verbose_name="Token"
#     )
#     # 多命名空间支持：每用户资源所在 ns
#     namespace = models.CharField(max_length=63, default='tenant-a')
#     created_at = models.DateTimeField(auto_now_add=True)
#     last_access_at = models.DateTimeField(null=True, blank=True)  # 用于回收策略

#     def __str__(self):
#         return f"{self.username}({self.id})"

# shared/models.py
from django.db import models
from django.contrib.auth.models import AbstractUser

ROLE_CHOICES = (
    ('admin', 'Admin'),
    ('tenant', 'Tenant'),
)

class User(AbstractUser):
    # 补充业务必需字段
    role = models.CharField(max_length=16, choices=ROLE_CHOICES, default='tenant')
    namespace = models.CharField(max_length=63, default='tenant-a')
    last_access_at = models.DateTimeField(null=True, blank=True)

    # 兼容旧逻辑：若你仍有历史 token 互操作，可临时保留
    legacy_token = models.CharField(max_length=256, null=True, blank=True, unique=True)

    def __str__(self):
        return f"{self.username}({self.id})"
"""

# ========== __init__.py ==========
# (空文件)

# ========== admin.py ==========
# (内容略)

# ========== apps.py ==========
# (内容略)

# ========== tests.py ==========
# (内容略)

# ========== views.py ==========
# (内容略)