# ========== managersvc 文件夹整合 ==========

# ========== Dockerfile ==========
"""
FROM python:3.10-alpine
WORKDIR /app
COPY shared /app/shared
COPY managersvc /app/managersvc
COPY shared/requirements.txt /app/requirements.txt
ENV DEBIAN_FRONTEND=noninteractive

# 安装系统依赖：
# - pkg-config：用于编译时查找库文件
# - default-libmysqlclient-dev：MySQL开发库
# - build-essential：提供编译工具（gcc等）
# - && rm -rf /var/lib/apt/lists/*：清理缓存，减小镜像体积
RUN apk add --no-cache \
    pkgconf \
    mysql-dev \
    gcc \
    musl-dev \
    && rm -rf /var/cache/apk/*
RUN pip install --no-cache-dir -r requirements.txt && \
    pip install --no-cache-dir gunicorn
# 设置Python路径
ENV PYTHONPATH=/app
WORKDIR /app/managersvc

ENV DJANGO_SETTINGS_MODULE=managersvc.settings
# 启两个进程：Django Web 与 Celery Worker 用不同容器（见 k8s yaml），这里只提供镜像
CMD ["tail", "-f", "/dev/null"]
# CMD ["gunicorn", "-b", "0.0.0.0:8000", "managersvc.wsgi:application", "--access-logfile", "-", "--error-logfile", "-", "--workers", "2", "--threads", "4"]
# CMD ["gunicorn", "-b", "0.0.0.0:8000", "authsvc.wsgi:application", "--access-logfile", "-", "--error-logfile", "-", "--capture-output", "--log-level=info", "--workers", "2", "--threads", "4"]
"""

# ========== manage.py ==========
"""
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'managersvc.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
"""

# ========== managersvc/__init__.py ==========
# (空文件)

# ========== managersvc/asgi.py ==========
"""
ASGI config for managersvc project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'managersvc.settings')

application = get_asgi_application()
"""

# ========== managersvc/middleware.py ==========
"""
import logging

class HealthCheckLogMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.logger = logging.getLogger('gunicorn.access')

    def __call__(self, request):
        # 检查是否是健康检查请求
        if request.path == '/health' and request.method == 'GET':
            # 临时关闭访问日志
            original_level = self.logger.level
            self.logger.setLevel(logging.CRITICAL)

        response = self.get_response(request)

        # 恢复日志级别
        if request.path == '/health' and request.method == 'GET':
            self.logger.setLevel(original_level)

        return response
"""

# ========== managersvc/settings.py ==========
"""
from shared.settings_base import *
INSTALLED_APPS += ['managersvc', 'users']
ROOT_URLCONF = 'managersvc.urls'
WSGI_APPLICATION = 'managersvc.wsgi.application'

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'managersvc.middleware.HealthCheckLogMiddleware',
    'shared.middleware.TenantMiddleware',
]

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]


AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

from celery.schedules import crontab
# 配置周期性任务
app.conf.beat_schedule = {
    'scale-idle-users': {
        'task': 'users.tasks.scale_idle_users_task',  # 对应 tasks.py 中的函数
        'schedule': crontab(minute='*/10'),  # 每 10 分钟执行一次
        # 也可以用 crontab，例如每分钟执行一次：
        # 'schedule': crontab(minute='*'),
        'args': (60,)  # 传递给任务的参数
    },
    # 更多任务示例：
    # 'daily-report': {
    #     'task': 'tasks.daily_backup',
    #     'schedule': crontab(hour=2, minute=0),  # 每天凌晨 2 点
    # }
}
"""

# ========== managersvc/urls.py ==========
"""
"""URL configuration for managersvc project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.urls import path, include
from django.http import JsonResponse
# from shared.models import TenantUser
from django.contrib.auth import get_user_model
User = get_user_model()
from shared.utils import jwt_encode
from django.contrib import admin
from users.views import health
from users.views import EnsureUserDeployment 

def issue_jwt(request, uid:int):
    try:
        # u = TenantUser.objects.get(id=uid)
        u = User.objects.get(id=uid)
        return JsonResponse({"token": jwt_encode({"uid": u.id})})
    except User.DoesNotExist:
        return JsonResponse({"error":"not found"}, status=404)

urlpatterns = [ path('issue-jwt/<int:uid>/', issue_jwt),
                path('health', health),
                path('wakeup/', EnsureUserDeployment.as_view()),
                # path('scale-down', ScaleDownUserDeployment.as_view()),
                # path('scale-up', ScaleUpUserDeployment.as_view()),
                path('admin/', admin.site.urls)]
"""

# ========== managersvc/wsgi.py ==========
"""
WSGI config for managersvc project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'managersvc.settings')

application = get_wsgi_application()
"""

# ========== users/views.py ==========
"""
from django.shortcuts import render
from django.db import connection
from django.utils import timezone
from rest_framework.response import Response
from rest_framework import status, permissions
from rest_framework.decorators import api_view
from rest_framework.views import APIView
from kubernetes import client
from .k8s import ensure_stack, scale_stack
from .tasks import scale_up_user_deployment

# Create your views here.
@api_view(['GET'])
def health(request):
    """健康检查端点，返回服务状态"""
    try:
        # 检查数据库连接
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
            cursor.fetchone()
        
        return Response({
            "status": "healthy",
            "service": "authsvc",
            "timestamp": timezone.now().isoformat()
        }, status=status.HTTP_200_OK)
    except Exception as e:
        return Response({
            "status": "unhealthy",
            "service": "authsvc",
            "error": str(e),
            "timestamp": timezone.now().isoformat()
        }, status=status.HTTP_503_SERVICE_UNAVAILABLE)




class EnsureUserDeployment(APIView):
    permission_classes = [permissions.AllowAny]  # 走内部签名，不强制 JWT
    def post(self, request):
        user_id = request.data.get("user_id")
        namespace = request.data.get("namespace", "default")
        
        if not user_id:
            return Response({"error": "user_id required"}, status=400)

        config.load_incluster_config()
        apps_v1 = client.AppsV1Api()
        deploy_name = f"user-{user_id}-nginx"

        try:
            deploy = apps_v1.read_namespaced_deployment(
                name=deploy_name, namespace=namespace
            )
            replicas = deploy.spec.replicas
            
            if replicas is None:
                return Response(
                    {"status": "not_found", "message": "Deployment not found"}, 
                    status=404
                )
            elif replicas == 0:
                # 触发异步扩容
                scale_up_user_deployment.delay(user_id, namespace)
                return Response(
                    {"status": "scaling", "message": "User pod waking up"}, 
                    status=202
                )
            elif replicas > 0:
                return Response({"status": "ready"})
                
        except client.exceptions.ApiException as e:
            if e.status == 404:
                return Response(
                    {"status": "not_found", "message": "Deployment not found"}, 
                    status=404
                )
            return Response({"error": str(e)}, status=500)
"""

# ========== users/k8s.py ==========
"""
from kubernetes import client, config
from django.conf import settings

def core():
    if settings.K8S_IN_CLUSTER:
        config.load_incluster_config()
    else:
        config.load_kube_config()
    return client.CoreV1Api()

def apps():
    if settings.K8S_IN_CLUSTER:
        config.load_incluster_config()
    else:
        config.load_kube_config()
    return client.AppsV1Api()

def names(user_id:int, ns:str):
    base = f"user-{user_id}"
    return {
        "deploy": f"{base}-nginx",
        "svc": f"{base}-svc",
        "labels": {"app":"user-nginx","user-id":str(user_id)}
    }

def ensure_namespace(ns: str):
    v1 = core()
    try:
        v1.read_namespace(ns)
    except client.exceptions.ApiException as e:
        if e.status == 404:
            body = client.V1Namespace(metadata=client.V1ObjectMeta(name=ns))
            v1.create_namespace(body)
        else:
            raise

def ensure_stack(user_id:int, ns:str):
    """
    确保用户命名空间和 Deployment、Service 存在
    打开 topologySpreadConstraints、affinity、podSecurityContext 等生产选项。
    """
    ensure_namespace(ns)
    v1 = core()
    a1 = apps()
    nm = names(user_id, ns)

    # Deployment（1 副本，带健康检查）
    dep = client.V1Deployment(
        metadata=client.V1ObjectMeta(name=nm["deploy"], labels=nm["labels"]),
        spec=client.V1DeploymentSpec(
            replicas=1,
            selector=client.V1LabelSelector(match_labels=nm["labels"]),
            template=client.V1PodTemplateSpec(
                metadata=client.V1ObjectMeta(labels=nm["labels"]),
                spec=client.V1PodSpec(containers=[
                    client.V1Container(
                        name="nginx",
                        image="nginx:alpine",
                        ports=[client.V1ContainerPort(container_port=80)],
                        readiness_probe=client.V1Probe(http_get=client.V1HTTPGetAction(path="/", port=80), initial_delay_seconds=2, period_seconds=5),
                        liveness_probe=client.V1Probe(http_get=client.V1HTTPGetAction(path="/", port=80), initial_delay_seconds=10, period_seconds=10),
                        resources=client.V1ResourceRequirements(
                            requests={"cpu":"50m","memory":"32Mi"},
                            limits={"cpu":"200m","memory":"128Mi"}
                        )
                    )
                ])
            )
        )
    )
    try:
        a1.create_namespaced_deployment(ns, dep)
    except client.exceptions.ApiException as e:
        if e.status != 409:
            raise

    # Service（ClusterIP，稳定名）
    svc = client.V1Service(
        metadata=client.V1ObjectMeta(name=nm["svc"], labels=nm["labels"]),
        spec=client.V1ServiceSpec(
            selector=nm["labels"],
            ports=[client.V1ServicePort(port=80, target_port=80)]
        )
    )
    try:
        v1.create_namespaced_service(ns, svc)
    except client.exceptions.ApiException as e:
        if e.status != 409:
            raise

def delete_stack(user_id:int, ns:str):
    v1 = core(); a1 = apps()
    nm = names(user_id, ns)
    opts = client.V1DeleteOptions(grace_period_seconds=10, propagation_policy='Foreground')
    for deleter, name in [(a1.delete_namespaced_deployment, nm["deploy"]),
                          (v1.delete_namespaced_service, nm["svc"])]:
        try:
            deleter(name=name, namespace=ns, body=opts)
        except client.exceptions.ApiException as e:
            if e.status != 404:
                raise

def scale_stack(user_id:int, ns:str, replicas:int):
    a1 = apps()
    nm = names(user_id, ns)
    body = {"spec": {"replicas": replicas}}
    a1.patch_namespaced_deployment_scale(name=nm["deploy"], namespace=ns, body=body)
"""

# ========== users/tasks.py ==========
"""
from shared.celery import app
# from shared.models import TenantUser
from django.contrib.auth import get_user_model
User = get_user_model()
import time
from kubernetes import client, config
from django.conf import settings
from .k8s import scale_stack, ensure_stack, delete_stack

@app.task(bind=True, max_retries=3, default_retry_delay=5)
def ensure_user_stack_task(self, user_id:int):
    try:
        # user = TenantUser.objects.get(id=user_id)
        user = User.objects.get(id=user_id)
        ensure_stack(user.id, user.namespace or settings.DEFAULT_USER_NS)
    except Exception as e:
        raise self.retry(exc=e)

@app.task(bind=True, max_retries=3, default_retry_delay=5)
def delete_user_stack_task(self, user_id:int, ns:str):
    try:
        delete_stack(user_id, ns)
    except Exception as e:
        raise self.retry(exc=e)

@app.task(bind=True)
def scale_idle_users_task(self, idle_minutes:int=60):
    """
    资源回收：将长时间未访问的用户 Deployment 缩容为 0；有请求时再由 ensure 任务或策略扩容。
    """
    from django.utils import timezone
    from datetime import timedelta
    threshold = timezone.now() - timedelta(minutes=idle_minutes)
    # qs = TenantUser.objects.filter(last_access_at__lt=threshold)
    qs = User.objects.filter(last_access_at__lt=threshold)
    for u in qs:
        try:
            scale_stack(u.id, u.namespace, replicas=0)
        except Exception:
            pass

@app.task(bind=True, max_retries=3, default_retry_delay=5)
def scale_up_user_deployment(self, user_id: int, namespace: str = "default", target_replicas: int = 1):
    """
    将名称为 user-{user_id}-nginx 的 Deployment 副本数调整为 target_replicas，
    并支持 Pod 就绪状态检查及通知等扩展逻辑。
    """
    try:
        # 调用 scale_stack 函数更新副本数
        scale_stack(user_id, namespace, replicas=target_replicas)
        
        # Pod 就绪状态检查
        if settings.K8S_IN_CLUSTER:
            config.load_incluster_config()
        else:
            config.load_kube_config()
        
        a1 = client.AppsV1Api()
        nm = names(user_id, namespace)
        deploy_name = nm["deploy"]
        
        timeout = 60  # 超时时间（秒）
        check_interval = 2  # 检查间隔（秒）
        elapsed_time = 0
        
        while elapsed_time < timeout:
            try:
                deployment = a1.read_namespaced_deployment(name=deploy_name, namespace=namespace)
                available_replicas = deployment.status.available_replicas or 0
                
                if available_replicas >= 1:
                    return {"status": "scaled", "user_id": user_id}
                
                time.sleep(check_interval)
                elapsed_time += check_interval
            except client.exceptions.ApiException as e:
                raise self.retry(exc=e)
        
        # 超时处理
        raise Exception(f"Deployment {deploy_name} in namespace {namespace} did not become ready within {timeout} seconds")
        
    except Exception as e:
        raise self.retry(exc=e)
"""

# ========== users/api.py ==========
"""
from rest_framework.viewsets import ModelViewSet, ReadOnlyModelViewSet
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth import get_user_model
from .permissions import IsAdmin, AdminOrTenantReadCreate

User = get_user_model()

class UserAdminViewSet(ModelViewSet):
    """
    管理员：用户全量管理（数据库操作权限/业务管理 API）
    """
    queryset = User.objects.all()
    serializer_class = None  # 省略：请按需补 DRF Serializer
    permission_classes = [IsAdmin]

class TaskViewSet(ModelViewSet):
    """
    任务 API（示例）：
    - admin：全权限
    - tenant：仅 GET（查看数据）与 POST（创建任务）
    """
    queryset = []  # 你的任务模型
    serializer_class = None
    permission_classes = [AdminOrTenantReadCreate]

    def create(self, request, *args, **kwargs):
        # tenant 可创建
        return Response({"ok": True}, status=201)
"""

# ========== users/auth_internal.py ==========
"""
import hmac, hashlib
from django.conf import settings

def verify_internal_signature(request):
    """
    使用 Ingress 注入的 X-Route-* 头来校验 Dispatcher→Manager 的内部调用。
    也可换成 mTLS/NetworkPolicy。
    """
    uid = request.headers.get("X-User-ID", "")
    ns  = request.headers.get("X-User-NS", "")
    ts  = request.headers.get("X-Route-Timestamp", "")
    sig = request.headers.get("X-Route-Signature", "")
    if not (uid and ns and ts and sig):
        return False
    msg = f"{uid}:{ns}:{ts}".encode()
    calc = hmac.new(settings.ROUTE_SIGNING_SECRET.encode(), msg, hashlib.sha256).hexdigest()
    return hmac.compare_digest(calc, sig)
"""

FZRYAOEHZN2M6HZX4JHQ3D6Z2WIXWRQP