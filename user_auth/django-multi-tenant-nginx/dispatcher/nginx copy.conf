worker_processes  auto;
events { worker_connections  10240; }

http {
  lua_shared_dict circuit 10m;
  lua_shared_dict user_cache 10m;  # 缓存用户状态
  resolver kube-dns.kube-system.svc.cluster.local valid=10s ipv6=off;

  # 简单限流：1r/s，突发 5
  limit_req_zone $binary_remote_addr zone=req:10m rate=1r/s;

    # 日志格式
  log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                  '$status $body_bytes_sent "$http_referer" '
                  '"$http_user_agent" "$http_x_forwarded_for" '
                  'user_id=$http_x_user_id namespace=$http_x_user_ns';

  server {
    listen 8080;
    set $default_ns "tenant-a";
        set $manager_host "http://managersvc.platform.svc.cluster.local:8000";


    location /healthz {
        access_log off;
        return 200 '{"status":"healthy","service":"dispatcher","timestamp":"$time_iso8601"}';
    }

    # 添加这部分来关闭 managersvc 健康检查的访问日志
    location /health {
        access_log off;
        proxy_pass http://managersvc.platform.svc.cluster.local:8000/health;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location / {
      limit_req zone=req burst=5 nodelay;
      access_log /var/log/nginx/access.log main;

      # 从 Ingress 透传头里读值
      set $userid $http_x_user_id;
      set $userns $http_x_user_ns;
      set $ts     $http_x_route_timestamp;
      set $sig    $http_x_route_signature;
      set $target "";

      access_by_lua_block {
        local userid = ngx.var.userid
        local userns = ngx.var.userns ~= "" and ngx.var.userns or ngx.var.default_ns
        local ts     = ngx.var.ts
        local sig    = ngx.var.sig

        -- 校验签名（与 AuthN 共用 ROUTE_SIGNING_SECRET）
        local secret = os.getenv("ROUTE_SIGNING_SECRET") or "route-sign"
        if not userid or userid == "" or not ts or ts == "" or not sig or sig == "" then
          return ngx.exit(401)
        end
        local msg = tostring(userid) .. ":" .. userns .. ":" .. tostring(ts)
        local hmac = ngx.encode_base16(ngx.hmac_sha256(secret, msg)):lower()
        if hmac ~= sig then
          return ngx.exit(401)
        end

        -- 简易熔断：若上游连续失败则短路
        local dict = ngx.shared.circuit
        local key = "cb:"..userid..":"..userns
        local failures = dict:get(key) or 0
        if failures >= 5 then
          return ngx.exit(503)
        end

        ngx.var.target = string.format("http://user-%s-svc.%s.svc.cluster.local", userid, userns)
      }

      proxy_http_version 1.1;
      proxy_set_header Connection "";
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-User-ID $userid;   # 透传日志追踪
      proxy_set_header X-User-NS $userns;

      proxy_next_upstream error timeout http_502 http_503 http_504;
      proxy_next_upstream_tries 3;
      proxy_read_timeout 15s;
      proxy_connect_timeout 3s;

      # 使用 Lua 设置的变量
      proxy_pass $target;

      log_by_lua_block {
        -- 上游失败计数
        local status = ngx.status
        local dict = ngx.shared.circuit
        local key = "cb:"..(ngx.var.userid or "none")..":"..(ngx.var.userns or "none")
        if status >= 500 then
          local f = (dict:get(key) or 0) + 1
          dict:set(key, f, 60)
        else
          dict:set(key, 0, 60)
        end
      }
    }
  }
}
