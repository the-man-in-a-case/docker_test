1. Django 认证微服务（查库 → 返回目标 Service 名）
2. 用户级 Deployment/Service（每个用户独立一套 Pod）
3. Nginx-Ingress 资源（带外部认证 + Lua 动态 upstream）

假设：

- 域名：`app.example.com`
- 用户 ID 为 `alice`、`bob` …，对应 Service 名 `user-alice`、`user-bob` …
- Django 认证微服务镜像：`myreg/django-auth:latest`

──────────────────────────────
1 Django 认证微服务 ──────────────────────────────
1.1 代码（app/auth/views.py）

Python



```python
import os
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from myapp.models import User   # 你的用户表

@csrf_exempt
def whoami(request):
    token = request.COOKIES.get("session") or request.headers.get("Authorization", "").replace("Bearer ", "")
    if not token:
        return JsonResponse({"error": "no token"}, status=401)

    try:
        user = User.objects.get(token=token)   # 按实际字段查
    except User.DoesNotExist:
        return JsonResponse({"error": "invalid token"}, status=403)

    # 返回目标 Service 名
    return JsonResponse(
        {"user": user.username},
        headers={"X-Target-Service": f"user-{user.username}"}
    )
```

1.2 路由（app/auth/urls.py）

Python



```python
from django.urls import path
from . import views

urlpatterns = [
    path("whoami", views.whoami),
]
```

1.3 打包镜像（Dockerfile）

dockerfile



```dockerfile
FROM python:3.11-slim
ENV PYTHONUNBUFFERED=1
WORKDIR /code
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["gunicorn", "project.wsgi:application", "-b", "0.0.0.0:8000"]
```

推送到仓库后得到 `myreg/django-auth:latest`。

──────────────────────────────
2 用户级 Deployment/Service（alice 为例） ──────────────────────────────

yaml



```yaml
# user-alice.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-alice
spec:
  replicas: 1
  selector:
    matchLabels: { app: user-alice }
  template:
    metadata:
      labels: { app: user-alice }
    spec:
      containers:
      - name: web
        image: myreg/django-app:latest   # 你真正的业务镜像
        env:
        - name: USER_ID
          value: "alice"
        ports:
        - containerPort: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: user-alice
spec:
  selector:
    app: user-alice
  ports:
  - port: 80
    targetPort: 8000
```

同文件把 `alice` 换成 `bob` 即可。

──────────────────────────────
3 认证服务部署 ──────────────────────────────

yaml



```yaml
# auth-deploy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
spec:
  replicas: 1
  selector:
    matchLabels: { app: auth-service }
  template:
    metadata:
      labels: { app: auth-service }
    spec:
      containers:
      - name: auth
        image: myreg/django-auth:latest
        ports:
        - containerPort: 8000
---
apiVersion: v1
kind: Service
metadata:
  name: auth-svc
spec:
  selector:
    app: auth-service
  ports:
  - port: 80
    targetPort: 8000
```

──────────────────────────────
4 Nginx-Ingress + 动态路由 ──────────────────────────────
4.1 ConfigMap：给 Nginx-Ingress Controller 加 Lua 片段

yaml



```yaml
# nginx-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-configuration
  namespace: ingress-nginx
data:
  server-snippet: |
    access_by_lua_block {
      local h = ngx.req.get_headers()
      local target = h["X-Target-Service"]
      if not target or target == "" then
        ngx.exit(ngx.HTTP_FORBIDDEN)
      end
      -- 目标 upstream 名 = <service>-<port>
      ngx.var.proxy_upstream_name = target .. "-80"
    }
```

4.2 Ingress 资源

yaml



```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: user-router
  annotations:
    nginx.ingress.kubernetes.io/auth-url: "http://auth-svc.default.svc.cluster.local/whoami"
    nginx.ingress.kubernetes.io/auth-signin: "https://login.example.com"
    nginx.ingress.kubernetes.io/auth-response-headers: "X-Target-Service"
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: dummy-backend   # 占位，会被 Lua 动态覆盖
            port:
              number: 80
```

> 4.1 的 Lua 片段已把 upstream 覆盖为 `user-alice-80`、`user-bob-80` … 因此无需真正存在 `dummy-backend`。

──────────────────────────────
5 一键部署





```bash
kubectl apply -f user-alice.yaml
kubectl apply -f user-bob.yaml
kubectl apply -f auth-deploy.yaml
kubectl apply -f nginx-cm.yaml
kubectl apply -f ingress.yaml
```

──────────────────────────────
6 验证

1. 登录拿到 Cookie

   ```
   curl -c cookie.txt -X POST https://login.example.com/api/login -d '{"user":"alice","pwd":"123"}'
   ```

   

2. 访问业务

   ```
   curl -b cookie.txt https://app.example.com/
   ```

   

   流量被送到 `user-alice-xxxxx` Pod。
   换 bob 的 Cookie 则送到 `user-bob-xxxxx` Pod。

至此，完成「基于 Django 的认证微服务 + Nginx-Ingress 按用户路由到独立 Pods」的完整闭环。









基于上述代码和yaml再给我一个，django程序可以在创建和删除用户时，同步创建或是删除对应pod的deployment。





下面给出“**增删用户时自动增删对应 Deployment/Pod**”的完整方案，全部基于 **Django + Kubernetes Python Client**，无需额外 Operator。

目录

1. 环境准备
2. Django 配置
3. 信号（signals）代码：创建/删除用户 → 同步 Deployment
4. RBAC 与 Secret
5. 一键部署 & 测试

──────────────────────────────
1 环境准备 ──────────────────────────────
• 容器镜像里除了业务依赖，还要装官方 Kubernetes Python 客户端：





```bash
pip install kubernetes
```

• 给 Django Pod 准备 **ServiceAccount + RBAC**（见第 4 节）。

──────────────────────────────
2 Django 配置 ──────────────────────────────
在 `settings.py` 里加一行，让代码知道在哪个命名空间操作：

Python



```python
K8S_NAMESPACE = os.getenv("K8S_NAMESPACE", "default")
```

──────────────────────────────
3 信号代码 ──────────────────────────────
3.1 创建 `apps.py` 并注册信号（Django 3.2+）

Python



```python
# myapp/apps.py
from django.apps import AppConfig

class MyAppConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "myapp"

    def ready(self):
        import myapp.signals   # noqa
```

3.2 信号实现（`myapp/signals.py`）

Python



```python
import os
import kubernetes
from django.conf import settings
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from .models import User   # 你的用户模型

# 在 Pod 内用 in-cluster 配置
kubernetes.config.load_incluster_config()
apps_v1 = kubernetes.client.AppsV1Api()

DEP_IMAGE = os.getenv("USER_APP_IMAGE", "myreg/django-app:latest")

def deploy_name(uid):
    return f"user-{uid}"

def service_name(uid):
    return f"user-{uid}"

@receiver(post_save, sender=User)
def create_user_deployment(sender, instance, created, **kwargs):
    if not created:
        return
    uid = str(instance.id)
    name = deploy_name(uid)

    container = kubernetes.client.V1Container(
        name="web",
        image=DEP_IMAGE,
        ports=[kubernetes.client.V1ContainerPort(container_port=8000)],
        env=[kubernetes.client.V1EnvVar(name="USER_ID", value=uid)]
    )

    template = kubernetes.client.V1PodTemplateSpec(
        metadata=kubernetes.client.V1ObjectMeta(labels={"app": name}),
        spec=kubernetes.client.V1PodSpec(containers=[container])
    )

    deploy = kubernetes.client.V1Deployment(
        api_version="apps/v1",
        kind="Deployment",
        metadata=kubernetes.client.V1ObjectMeta(name=name),
        spec=kubernetes.client.V1DeploymentSpec(
            replicas=1,
            selector=kubernetes.client.V1LabelSelector(match_labels={"app": name}),
            template=template
        )
    )
    apps_v1.create_namespaced_deployment(namespace=settings.K8S_NAMESPACE, body=deploy)

    # 同时创建 Service
    core_v1 = kubernetes.client.CoreV1Api()
    svc = kubernetes.client.V1Service(
        api_version="v1",
        kind="Service",
        metadata=kubernetes.client.V1ObjectMeta(name=service_name(uid)),
        spec=kubernetes.client.V1ServiceSpec(
            selector={"app": name},
            ports=[kubernetes.client.V1ServicePort(port=80, target_port=8000)]
        )
    )
    core_v1.create_namespaced_service(namespace=settings.K8S_NAMESPACE, body=svc)


@receiver(post_delete, sender=User)
def delete_user_deployment(sender, instance, **kwargs):
    uid = str(instance.id)
    name = deploy_name(uid)

    apps_v1.delete_namespaced_deployment(name=name, namespace=settings.K8S_NAMESPACE)
    core_v1 = kubernetes.client.CoreV1Api()
    core_v1.delete_namespaced_service(name=service_name(uid), namespace=settings.K8S_NAMESPACE)
```

──────────────────────────────
4 RBAC & Secret ──────────────────────────────
让 Django Pod 有权限操作 Deployment/Service：

yaml



```yaml
# rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: django-sa
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: django-cr
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "create", "delete"]
- apiGroups: [""]
  resources: ["services"]
  verbs: ["get", "list", "create", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: django-crb
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: django-cr
subjects:
- kind: ServiceAccount
  name: django-sa
  namespace: default
```

在 Django Deployment 里指定该 ServiceAccount：

yaml



```yaml
spec:
  template:
    spec:
      serviceAccountName: django-sa
```

──────────────────────────────
5 一键部署 & 测试 ──────────────────────────────

1. 部署 RBAC、Django 主应用、认证服务、Nginx-Ingress（见上一回答）。
2. 登录 Django Admin → “用户” → 新增 `charlie`，立刻能看到：





```bash
kubectl get deploy,svc | grep user-charlie
```

1. 删除用户 `charlie`，资源自动消失。

至此，Django 用户生命周期与 Kubernetes Deployment / Service 完全同步。